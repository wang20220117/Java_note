[TOC]



# 集合

Java中集合分为**单列集合**和**双列集合**

在添加数据时

单列集合，每次只能添加一个元素。单列集合的顶层接口是`Collection`。

双列集合，每次添加两个元素。（类似于字典，添加键值对）

## 单列集合

### 单列集合顶层接口 Collection

![image-20240611205508306](D:\md_image\image-20240611205508306.png)

**List系列集合**：添加的元素是 <u>有序（存和取的顺序是一样的）、可重复、有索引（可通过索引去获取集合中的元素）</u>

**Set系列集合**：无序、不重复、无索引

Collection 是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。

常用方法：

![image-20240611205929118](D:\md_image\image-20240611205929118.png)



注意点：

Collection 是一个接口，我们不能直接创建它的对象。

所以，我们只能创建它实现类的对象。其中一个实现类 `ArrayList`



为了学习Collection接口里面的方法，以多态的形式创建对象



**添加元素：**

```java
        Collection<String> coll = new ArrayList<>();
        //1 添加元素
        coll.add("aaa");
        System.out.println(coll);
```

细节：

1. 如果我们往List集合中添加元素，那么方法永远返回true，因为List系列集合允许元素重复。
2. 如果我们往Set集合中添加元素，那么方法返回值不一定为true，当前元素不存在返回true，存在则返回false，表示添加失败。



**删除元素：**

因为Collection中定义的是共性的方法，所以不能通过索引删除，只能通过元素的对象进行删除。

```java
boolean result = coll.remove("aaa");
```

删除成功返回true，删除失败返回false。



**判断元素是否包含：**

```java
boolean result = coll.contains("aaa");
```

细节：

底层是依赖equals方法进行判断是否存在的。

所以，如果集合中存储的自定义对象，也想通过contains方法来判断是否包含，那么在JavaBean中一定要重写equals方法。



### Collection集合的通用遍历方式

均适合List和Set系列集合

有三种：

* 迭代器遍历
* 增强for遍历
* Lambda表达式遍历



#### 迭代器遍历

迭代器不依赖索引

迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式。

![image-20240611212644758](D:\md_image\image-20240611212644758.png)

大致三步：

1. 创建迭代器对象 
2. 判断当前位置是否有元素。 hasNext()
3. 获取当前位置的元素，并将迭代器对象移向下一个位置。next()



```java
        Collection<String> coll = new ArrayList<>();
        
        coll.add("aaa");
        coll.add("bbb");
        coll.add("ccc");
        coll.add("ddd");

        Iterator<String> it = coll.iterator();
        while (it.hasNext()) {
            String s = it.next();
            System.out.println(s);
        }
```



迭代器细节：

1. 当迭代器指针在集合末尾时，再使用`it.next()`，会报错`NoSuchElementException`
2. 迭代器遍历完毕，指针不会复位。（想要重新遍历，只能再创建一个迭代器对象）
3. 循环中只能用一次next方法。（因为每使用一次就会移动一次指针，想使用多次，只能先用一个变量去记录，后面多次使用变量）
4. ***迭代器遍历时，不能用集合的方法进行增加或者删除。（出现 并发修改异常 的错误）*** 
   1. 可以使用迭代器中的方法去删除，it.remove();
   2. 如果要添加，暂时没有办法。



#### 增强for遍历

* 增强for的底层就是Iterator迭代器，JDK5之后出现。
* 所有的 **单列集合** 和 **数组** 才能用增强for迭代器。



**格式：**

for(元素的数据类型   变量名  ： 数组或者集合){

}

```java
for(String s : list){
	System.out.println(s);
}
```

idea的快速生成方式：

`集合名.for`

细节：

* 增强for中的 s 仅仅是一个第三方变量，修改 s 不会改变集合中原本的数据。



#### Lambda 表达式遍历

从JDK8开始有的，因为Lambda表达式是JDK8才有的。

利用一个`forEach`方法：

![image-20240611221352262](D:\md_image\image-20240611221352262.png)

```java
    public static void main(String[] args) {
        //1 创建集合并添加元素
        Collection<String> coll = new ArrayList<>();
        coll.add("aaa");
        coll.add("bbb");
        coll.add("ccc");
        coll.add("ddd");

        //2 利用匿名内部类的形式进行遍历 ， 重写Consumer接口中的accept方法
//        coll.forEach(new Consumer<String>() {
//            @Override
//            // s 依次表示集合中的每一个数据
//            public void accept(String s) {
//                System.out.println(s);
//            }
//        });

        //3 将匿名内部类改写成 Lambda 表达式
        coll.forEach(s->System.out.println(s));

    }
```





**forEach方法的底层原理：**

在底层，自己遍历集合依次得到每一个元素，把得到的每一个元素传递给下面的accept方法。





#### 单列集合的三种通用遍历方式总结

* 迭代器：在遍历的过程中需要删除元素，请使用迭代器。

* 增强for、Lambda

  ​		适用于 仅仅想遍历的情况。



### List 系列集合

* List 也是个接口
* Collection的方法List都继承了。
* List集合因为有索引，所以多了很多索引操作的方法。



以下四个方法对应增删改查：

![image-20240612102437625](D:\md_image\image-20240612102437625.png)

**添加元素：**

就是插入，插入位置后面的元素依次往后去。



**删除元素：**



![image-20240612103414683](D:\md_image\image-20240612103414683.png)

此时删除的是1这个元素还是1索引上的元素？

在调用方法时，如果方法出现了重载现象，则优先调用，*<u>实参和形参类型一致</u>*的那个方法。

如果想调用 remove(Object o) ，那么需要手动装箱

```java
Integer i1 = 1;
list.remove(i1);
```



#### List 集合独有的遍历方式

* 列表迭代器遍历
* 普通for循环



**普通for循环：**

利用size() 方法和get() 方法

```java
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
```



**ListInterator 列表迭代器：**

相比于Interator 额外添加了一个方法：在遍历的过程中，可以添加元素。

```java
        ListIterator<Integer> li = list.listIterator();
        while (li.hasNext()) {
            Integer i = li.next();
            if (i.equals(2)) {
                li.add(4);   //迭代器自身的方法，添加元素，不会引发 并发修改异常
            }
        }
        for (Integer i : list) {
            System.out.println(i);
        }
```

![image-20240612111219742](D:\md_image\image-20240612111219742.png)



### ArrayList 集合

底层原理：

* ArrayList底层是数组结构的。

1. 利用空参创建的ArrayList集合，在底层创建一个默认长度为0的数组，数组名为elementData

![image-20240612112623325](D:\md_image\image-20240612112623325.png)

2. 添加第一个元素时，底层会创建一个新的长度为10的数组

![image-20240612112951471](D:\md_image\image-20240612112951471.png)

ArrayList 中的 size 成员变量 有两层含义：1 元素个数，2 下次存入位置



3. 存满时，会扩容1.5倍
4. 如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准。



### LinkedList 集合

* 底层数据结构是**双向链表**，查询慢，增删快，但是如果操作的是首尾元素，速度也很快。
* LinkedList 本身提供了很多直接操作首尾元素的特有API，了解即可

![image-20240612141041769](D:\md_image\image-20240612141041769.png)

底层源码：

![image-20240612142017148](D:\md_image\image-20240612142017148.png)



### 迭代器的底层原理

cursor：指针

modCount：集合变化次数

![image-20240612143227405](D:\md_image\image-20240612143227405.png)



### 泛型深入

泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。

泛型的格式：<数据类型>

注意：泛型只能支持引用数据类型。如果想用基本数据类型，需要写它的包装类。



**没有泛型时，集合如何存储数据？**

如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合中添加任意的数据类型。这样带来一个坏处：我们在获取数据的适合，无法使用它的特有行为。

因此，Java推出了泛型，可以在添加数据的时候就把类型进行统一。而且我们在获取数据的时候，也省的强制转换了。



**泛型的好处：**

* 统一数据类型
* 把运行期间的问题提前到了编译期间，在编译阶段类型就能确定下来，避免了强制类型转换可能出现的异常。



拓展知识点：Java中的泛型是**伪泛型**。只是在编译阶段限制添加对象的类型，但在底层还是被当作Object类型，但当获取时集合的底层会按照泛型的类型额外做了一次强转

**泛型的擦除：**

在Java中泛型是存在的，但当编译为字节码文件时，泛型就会消失，这称作泛型的擦除。



**泛型的细节：**

* 泛型中不能写基本数据类型
* 指定泛型的具体类型后，传入数据时，可以传入该类类型或者其子类类型。
* 如果不写泛型，类型默认是Object



泛型写在：

| 类后面 | 方法上面 | 接口后面 |
| ------ | -------- | -------- |
| 泛型类 | 泛型方法 | 泛型接口 |

#### 泛型类

使用场景：当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类。

==<类型>写在类名后==

格式：

​		修饰符 class 类名<类型>{

​		}

举例：

​		public class ArrayList<E>{

​		}

此处E可以理解为变量，但不是用来记录数据的，而是记录数据的类型，常写作E （element的简写）。



```java
//定义一个泛型类
public class MyArrayList<E> {
    Object[] obj = new Object[10];
    int size;
    
    public boolean add(E e) {
        obj[size] = e;
        size++;
        return true;
    }
    
    public E get(int index) {
        return (E) obj[index];
    }
    
}
```



#### 泛型方法和泛型接口

当方法中形参类型不确定时：

​		有两种方案：1. 使用类名后面定义的泛型（所有方法均可使用）。   2. 在方法声明上定义自己的泛型（只有本方法可用）。

**泛型方法格式：**

==在修饰符后面加<泛型>==

```
修饰符<类型>返回值类型  方法名( 类型 变量名){             //在修饰符后面加<泛型>

}
```



**泛型接口格式：**

==与泛型类类似，在接口名后加<类型>==

```
修饰符 interface 接口名<类型>{

}
```



**如何使用一个泛型？（重点）**

1. **实现类给出具体的类型**
2. **实现类延续泛型，创建对象时再确定。**



```java
//实现类给出具体的类型
public class MyArrayList  implements List<String>{
    ...
}

//实现类延续泛型，创建对象时再确定。
public class MyArrayList<E>  implements List<E>{
    ...
}

//实例化时确定
MyArrayList<String> list = new MyArrayList<>();
```



#### 泛型的通配符

* **泛型不具备继承性**，但是数据具备继承性

![image-20240612162642202](D:\md_image\image-20240612162642202.png)

* 泛型的通配符： ？ 和E作用一样

  ​							？extend E 表示E和E的子类

  ​							？super E   表示E和E的父类

* 使用场景：

  * 定义类、方法、接口的时候类型不确定，但能知道是哪个继承体系中的，就可以使用泛型的通配符。





### 平衡二叉树

![image-20240612164341355](D:\md_image\image-20240612164341355.png)

![image-20240612164521126](D:\md_image\image-20240612164521126.png)

![image-20240612164623997](D:\md_image\image-20240612164623997.png)

![image-20240612164654478](D:\md_image\image-20240612164654478.png)



二叉树插入导致不平衡的四种情况：

左左：一次右旋

左右：先局部左旋变为左左的形式，再整体右旋

右右：一次左旋

右左：先局部右旋变为右右的形式，再整体左旋

### 红黑树

* 是一种特殊的**二叉查找树**，红黑树的每一个节点上都有存储位表示节点的颜色。
* 每一个节点可以是红或者黑；红黑树**不是高度平衡的**，它的平衡是通过"**红黑规则**"进行实现的。

红黑规则：

![image-20240612165734247](D:\md_image\image-20240612165734247.png)

红黑树添加节点的规则：

* 添加的节点默认是红色的（效率高）



![image-20240612170405046](D:\md_image\image-20240612170405046.png)

红黑树的增删改查的性能很好。



### Set系列集合

* 无序
* 不重复
* 无索引



Set集合的三个实现类：

* HashSet：无序、不重复、无索引
* LinkedHashSet：***有序***、不重复、无索引
* TreeSet：***可排序***、不重复、无索引

Set接口中的方法基本上与Collection的API一致。



### HashSet底层原理

* HashSet 集合底层采取哈希表存储数据。
* 哈希表是一种对于增删改查数据性能都较好的结构。

**哈希表组成：**

* JDK8之前：数组+链表
* JDK8之后：数组+链表+红黑树

**哈希值：**

![image-20240612215715574](D:\md_image\image-20240612215715574.png)



![image-20240612220808478](D:\md_image\image-20240612220808478.png)

加载因子：HashSet的扩容时机。当数组中存了 16*加载因子 个元素的时候，数组就会扩容到原先的两倍。

​					当链表的长度大于8 而且数组的长度大于等于64时，链表就会**转为红黑树**，提高查找效率。



**如果集合中存储的是自定义的对象，必须要重写hashCode和equals方法。**如果不重写，在底层都是通过地址值来计算和比较的。



HashSet 是利用什么机制保证数据去重的？

答：利用 HashCode方法和equals方法。利用 HashCode方法得到哈希值从而确定添加到数组中的哪个位置，使用equals方法比较同位置的对象的属性值是否相同。



### LinkedHashSet 底层原理

LinkedHashSet 是HashSet的子类

* ***有序***、不重复、无索引
* 这里的有序指的是保证存储和取出的元素顺序一致。
* 原理：底层数据结构仍然是哈希表，只是每个元素又额外的多了一个***双向链表***的机制记录元素存储的顺序。

![image-20240612223403935](D:\md_image\image-20240612223403935.png)

### TreeSet 

* 不重复、无索引、***可排序***
* 可排序：按照元素的默认规则（由小到大）排序。
* TreeSet集合底层是基于***红黑树的数据结构***实现排序的。

![image-20240612224256019](D:\md_image\image-20240612224256019.png)

使自定义类实现TreeSet 内部排序有两种方式：

​	方式一：***默认排序/自然排序***：JavaBean类实现Comparable接口指定比较规则。

​	方式二：比较器排序：创建TreeSet对象的时候，传递比较器Comparator指定规则。

使用原则：默认使用第一种，如果第一种不能满足当前需求，就使用第二种。

细节：方式一和方式二都存在的情况下，以方式二为准。

<img src="D:\md_image\image-20240612230415994.png" alt="image-20240612230415994" style="zoom:50%;" />

不管方式一还是方式二，重写接口时，当方法的返回值是：

* 负数：表示当前要添加的元素是小的，存左边。
* 正数：表示当前要添加的元素是大的，存右边。
* 0：表示当前要添加的元素已经存在，舍弃。



![image-20240612232124069](D:\md_image\image-20240612232124069.png)
